<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title>Add multiple geometries from one GeoJSON source</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no'>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.css' rel='stylesheet'>
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.js'></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id='controls'
        style='position: absolute; top: 10px; right: 10px; z-index: 1; background: white; padding: 10px; border-radius: 5px; font-family: Arial, sans-serif; font-size: 14px; color: #333;'>
        <label for='deveui-select' style="font-weight: bold;">DevEUI:</label>
        <select id='deveui-select' style='width: 200px; margin-top: 5px; padding: 5px; font-size: 14px;'>
            <option value='' disabled selected>Loading...</option>
        </select>
        <div id='deveui-details' style='margin-top: 10px;'>
            <label for='tsdevice-select' style="font-weight: bold;">Timestamp:</label>
            <select id='tsdevice-select' style='width: 200px; margin-top: 5px; padding: 5px; font-size: 14px;' disabled>
                <option value="" disabled selected>Select DevEUI first</option>
            </select>
            <input type="text" id="tsdevice-input"
                style="width: 200px; display: none; margin-top: 5px; padding: 5px; font-size: 14px;" readonly>
        </div>
        <div id="live-view-control" style="margin-bottom: 8px;">
            <label for="live-view" style="font-weight: bold;">LiveView:</label>
            <input type="checkbox" id="live-view" style="margin-left: 5px;" disabled>
        </div id='zoom-details' style='margin-top: 10px;'>
        <div>
            <label for="enable-zoom" style="font-weight: bold;">Auto Zoom:</label>
            <input type="checkbox" id="enable-zoom" style="margin-left: 5px;" disabled>
        </div>
        <div id="number-of-objects" style="margin-bottom: 8px;">
            <label for="object-number" style="font-weight: bold;">Number of Objects:</label>
            <input type="number" id="object-number" value="20"
                style="width: 80px; margin-left: 5px; padding: 3px; font-size: 14px;">
        </div>
        <div id="device-count-info">
            <strong style="font-weight: bold;">Received Gateways:</strong>
            <span id="device-count-value"
                style="font-weight: normal; margin-top: 5px; margin-left: 5px; padding: 5px; font-size: 14px;">-</span>
        </div>
    </div>
    <div id='map' style='height: 100vh;'></div>
    <script>
        //variable to check timestamps
        let lastTsDevice = null;

        //create the Map
        mapboxgl.accessToken = 'pk.eyJ1IjoibWlub2x6ZW5uZXJjb25uZWN0IiwiYSI6ImNqd3J1NGlsbjAwb2czeXBjdTd5YnB5dmQifQ.diu3fG0GE56_reHr7avgqQ';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/outdoors-v12',
            center: [9.1635, 48.69521666666667],
            zoom: 10
        });

        // Fetch timestamps for a specific DevEUI
        async function fetchTimestamps(deveui) {
            const myHeaders = new Headers();
            myHeaders.append("Content-Type", "application/json");

            const raw = JSON.stringify({
                deveui: deveui
            });

            const requestOptions = {
                method: "POST",
                headers: myHeaders,
                body: raw,
                redirect: "follow"
            };

            try {
                const response = await fetch("https://cockpit.zenner-connect.com/mzc-api/adeunis_live_view_data/timestamps", requestOptions);

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const result = await response.json();

                if (!result.result_list || !Array.isArray(result.result_list)) {
                    throw new Error("Invalid response format: Missing `result_list`");
                }

                return result.result_list;
            } catch (error) {
                console.error("Error fetching timestamps:", error);
                return [];
            }
        }

        let tsDataLoaded = false;

        // Populate the TSDevice dropdown
        async function populateTSDeviceDropdown(deveui) {
            const tsDeviceSelect = document.getElementById("tsdevice-select");
            const liveView = document.getElementById('live-view');
            tsDeviceSelect.disabled = true;
            liveView.disabled = true;

            //loading of the timestamps
            const timestamps = await fetchTimestamps(deveui);

            if (timestamps.length === 0) {
                tsDeviceSelect.innerHTML = '<option value="" disabled>No Timestamps found</option>';
                tsDataLoaded = false;
                return;
            }

            //Delete all options and add new ones
            tsDeviceSelect.innerHTML = '';
            timestamps.forEach(ts => {
                const option = document.createElement("option");
                const date = new Date(ts * 1000);
                option.value = ts;
                option.textContent = `${date.toLocaleDateString()}, ${date.toLocaleTimeString()}`;
                tsDeviceSelect.appendChild(option);
            });

            liveView.disabled = false;
            tsDeviceSelect.disabled = false;
            tsDataLoaded = true;
        };

        // Fetch and display GeoJSON for a specific TSDevice
        async function fetchGeoJSONForTimestamp(deveui, tsdevice) {
            const myHeaders = new Headers();
            myHeaders.append("Content-Type", "application/json");

            const raw = JSON.stringify({
                deveui: deveui,
                number_of_geojsons: 1,
                timestamp: tsdevice
            });

            const requestOptions = {
                method: "POST",
                headers: myHeaders,
                body: raw,
                redirect: "follow"
            };

            try {
                const response = await fetch("https://cockpit.zenner-connect.com/mzc-api/adeunis_live_view_data", requestOptions);

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const result = await response.json();
                const geojson = result.result_list[0]?.geojson;

                if (!geojson) {
                    throw new Error("GeoJSON data not found in the API response");
                }

                geojson.features = geojson.features.filter(feature => {
                    if (feature.geometry.type === "Point") {
                        const [lng, lat] = feature.geometry.coordinates;
                        return lng !== null && lat !== null && !(lng === 0 && lat === 0);
                    }
                    return true
                });

                return geojson;
            } catch (error) {
                console.error("Error fetching GeoJSON data:", error);
                return null;
            }
        };

        //function to fetch all DevEUIs
        async function fetchAllDevEUIs() {
            const myHeaders = new Headers();
            myHeaders.append("Content-Type", "application/json");

            const requestOptions = {
                method: "GET",
                headers: myHeaders,
                redirect: "follow"
            };

            try {
                const response = await fetch("https://cockpit.zenner-connect.com/mzc-api/adeunis_live_view_data", requestOptions);

                console.log("Response: ", response);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const result = await response.json();

                if (!result.result_list || !Array.isArray(result.result_list)) {
                    throw new Error("Invalid response format: Missing `result_list`");
                }

                return result.result_list;
            } catch (error) {
                console.error("Error fetching DevEUIs:", error);
                return [];
            }
        };

        //function to populate Dropdown DevEUI
        async function populateDevEUISDropdown() {
            const deveuis = await fetchAllDevEUIs();
            const select = document.getElementById('deveui-select');

            if (deveuis.length === 0) {
                select.innerHTML = '<option value="" disabled>No DevEUI found</option>';
                return;
            }

            select.innerHTML = '<option value="" disabled selected>Select DevEUI</option>';

            deveuis.forEach(devEUI => {
                const option = document.createElement('option');
                option.value = devEUI;
                option.textContent = devEUI;
                select.appendChild(option);
            });
        };

        //Function to load the geoJson Object to the map
        async function loadGeoJSONToMap(deveui) {
            try {
                //set Data to fetched Data
                const geojsonData = await fetchGeoJSON(deveui);
                if (!geojsonData) {
                    console.error('No GeoJSON data found for the selected DevEUI.');
                    return null;
                }

                //set Data to new fetched Data
                if (!map.getSource('dynamic-geojson')) {
                    map.addSource('dynamic-geojson', {
                        type: 'geojson',
                        data: geojsonData
                    });
                } else {
                    map.getSource('dynamic-geojson').setData(geojsonData);
                }

                console.log('GeoJSON data successfully loaded for DevEUI:', deveui);
                return geojsonData;
            } catch (error) {
                console.error('Error loading GeoJSON data for DevEUI:', deveui, error);
                return null;
            }
        };

        //function to fetch the tsdevice of the DevEUI
        async function fetchtsdevice(deveui) {
            const myHeaders = new Headers();
            myHeaders.append("Content-Type", "application/json");

            const raw = JSON.stringify({
                "deveui": deveui
            });

            const requestOptions = {
                method: "POST",
                headers: myHeaders,
                body: raw,
                redirect: "follow"
            };

            try {
                const response = await fetch("https://cockpit.zenner-connect.com/mzc-api/adeunis_live_view_data/timestamps", requestOptions);

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const result = await response.json();

                if (!result.result_list || !Array.isArray(result.result_list)) {
                    throw new Error("Invalid response format: `result_list` is missing or not an array");
                }

                const latestTimestamp = Math.max(...result.result_list);

                if (!latestTimestamp || isNaN(latestTimestamp)) {
                    throw new Error("No valid timestamp found in the response");
                }

                const date = new Date(latestTimestamp * 1000);
                const formattedDate = date.toLocaleDateString('de-DE');
                const formattedTime = date.toLocaleTimeString('de-DE');

                return `${formattedDate}, ${formattedTime}`
            } catch (error) {
                console.error("Error fetching timestamp data:", error);
                return null;
            }
        };

        //function to fetch the geoJson of the DevEUI LiveView
        async function fetchGeoJSONForLiveView(deveui, formattedTimestamp) {
            const myHeaders = new Headers();
            const [datePart, timePart] = formattedTimestamp.split(', ');
            const [day, month, year] = datePart.split('.').map(Number);
            const [hours, minutes, seconds] = timePart.split(':').map(Number);
            const date = new Date(year, month - 1, day, hours, minutes, seconds);
            if (isNaN(date.getTime())) {
                throw new Error('Invalid date format or value');
            }
            const ts = Math.floor(date.getTime() / 1000);

            myHeaders.append("Content-Type", "application/json");

            const raw = JSON.stringify({
                "deveui": deveui,
                "number_of_geojsons": 1,
                "timestamp": ts
            });

            const requestOptions = {
                method: "POST",
                headers: myHeaders,
                body: raw,
                redirect: "follow"
            };

            try {
                const response = await fetch("https://cockpit.zenner-connect.com/mzc-api/adeunis_live_view_data", requestOptions);

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const result = await response.json();

                if (!result.result_list || !Array.isArray(result.result_list)) {
                    throw new Error("Invalid response format: `result_list` is missing or not an array");
                }

                const geojson = result.result_list[0].geojson;

                if (!geojson) {
                    throw new Error("GeoJSON data not found in the API response");
                }

                geojson.features = geojson.features.filter(feature => {
                    if (feature.geometry.type === "Point") {
                        const [lng, lat] = feature.geometry.coordinates;
                        return lng !== null && lat !== null && !(lng === 0 && lat === 0);
                    }
                    return true
                });

                return geojson;
            } catch (error) {
                console.error("Error fetching GeoJSON data:", error);
                return null;
            }
        };

        //geoJson is processed
        async function executeData(deveui, tsdevice) {
            //variables to check for liveview or timestamp
            const isLiveView = document.getElementById('live-view').checked;
            const tsSelect = document.getElementById('tsdevice-select');
            const tsInput = document.getElementById('tsdevice-input');
            const objectNumber = document.getElementById('object-number');
            const enableZoom = document.getElementById('enable-zoom').checked;
            let isNewData = false;
            let geojsonData = null;

            // Check if the data is new based on tsdevice
            if (!isLiveView) {
                const deviceValue = document.getElementById('tsdevice-select').value;
                isNewData = deviceValue !== lastTsDevice;
                lastTsDevice = deviceValue;
            } else {
                const deviceValue = document.getElementById('tsdevice-input').value;
                isNewData = deviceValue !== lastTsDevice;
                lastTsDevice = deviceValue;
            }

            if (isNewData) {
                if (isLiveView) {
                    geojsonData = await fetchGeoJSONForLiveView(deveui, tsdevice);
                    if (geojsonData) {
                        processGeoJSONData(geojsonData);
                    } else {
                        console.error('Failed to load GeoJSON data');
                        return;
                    };
                } else {
                    const tsdevice = tsSelect.value;
                    if (!tsdevice) {
                        console.error("No Timestamp selected.");
                        return;
                    };
                    geojsonData = await fetchGeoJSONForTimestamp(deveui, tsdevice);
                    if (geojsonData) {
                        processGeoJSONData(geojsonData);
                    } else {
                        console.error('Failed to load GeoJSON data');
                        return;
                    };
                }

                //add counter
                const counterSpan = document.getElementById('device-count-value');
                let counterValue = 0;
                geojsonData.features.forEach(feature => {
                    if (feature.geometry.type === "Point") {
                        if (feature.properties.macAddress) {
                            counterValue++;
                        }
                    }
                });

                counterSpan.textContent = counterValue;

                //delete old Layers
                const layersToRemove = ['lines-layer', 'clusters', 'device-icons-layer', 'cluster-count'];
                layersToRemove.forEach(layerId => {
                    if (map.getLayer(layerId)) {
                        map.removeLayer(layerId);
                    }
                });

                //delete old sources
                const sourcesToRemove = ['dynamic-geojson', 'points-and-lines'];
                sourcesToRemove.forEach(sourceId => {
                    if (map.getSource(sourceId)) {
                        map.removeSource(sourceId);
                    }
                });

                //add geojson source
                map.addSource('dynamic-geojson', {
                    type: 'geojson',
                    data: geojsonData,
                    cluster: true,
                    clusterRadius: 50,
                    clusterMaxZoom: 14
                });

                //add line source
                map.addSource('points-and-lines', {
                    'type': 'geojson',
                    'data': geojsonData
                });

                //add cluster-layer
                map.addLayer({
                    id: 'clusters',
                    type: 'circle',
                    source: 'dynamic-geojson',
                    filter: ['has', 'point_count'],
                    paint: {
                        'circle-color': [
                            'step',
                            ['get', 'point_count'],
                            '#51bbd6', 3,
                            '#f1f075', 5,
                            '#f28cb1'
                        ],
                        'circle-radius': [
                            'step',
                            ['get', 'point_count'],
                            15, 10,
                            20, 20,
                            25
                        ]
                    },
                    layout: {
                        'visibility': 'none'
                    }

                });

                //add cluster-count
                map.addLayer({
                    id: 'cluster-count',
                    type: 'symbol',
                    source: 'dynamic-geojson',
                    filter: ['has', 'point_count'],
                    layout: {
                        'text-field': '{point_count}',
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': 12,
                        'text-anchor': 'center',
                        'text-offset': [0, 0],
                        'visibility': 'none'
                    },
                    paint: {
                        'text-color': '#ffffff'
                    }
                });

                //add line-layer
                map.addLayer({
                    id: 'lines-layer',
                    type: 'line',
                    source: 'points-and-lines',
                    filter: ['==', '$type', 'LineString'],
                    layout: {
                        'line-join': 'round',
                        'line-cap': 'round',
                        'visibility': 'visible'
                    },
                    paint: {
                        'line-width': 4,
                        'line-color': [
                            'match',
                            ['get', 'category'],
                            'reception possible (good)', '#00FF00',
                            'reception conditionally possible (not reliable)', '#FFFF00',
                            'no reception possible (bad)', '#FF0000',
                            '#000000'
                        ]
                    }
                });

                //add icon-layer
                map.addLayer({
                    id: 'device-icons-layer',
                    type: 'symbol',
                    source: 'points-and-lines',
                    filter: ['==', '$type', 'Point'],
                    layout: {
                        'icon-image': [
                            'case',
                            ['==', ['get', 'deviceType'], 'Tester'], 'Tester_black',
                            ['concat',
                                ['get', 'deviceType'],
                                '_',
                                ['match', ['get', 'category'],
                                    'reception possible (good)', 'green',
                                    'reception conditionally possible (not reliable)', 'yellow',
                                    'no reception possible (bad)', 'red',
                                    'black'
                                ]
                            ]
                        ],
                        'icon-size': [
                            'interpolate', ['linear'], ['zoom'],
                            1, 0.2,
                            5, 0.1,
                            10, 0.075
                        ],
                        'icon-allow-overlap': true,
                        'text-field': ['to-string', ['get', 'point_count']],
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': 12,
                        'text-offset': [0, -1.5],
                        'text-allow-overlap': true,
                        'visibility': 'visible'
                    }
                });

                //Zoom only if enable zoom is active
                if (enableZoom) {
                    // Zoom to bounds only if the data is new
                    const bounds = new mapboxgl.LngLatBounds();

                    geojsonData.features.forEach(feature => {
                        if (feature.geometry.type === "Point") {
                            bounds.extend(feature.geometry.coordinates);
                        }
                    });

                    //Variable to get the Height of the Input-Box
                    const controlsHeights = document.getElementById('controls').offsetHeight;

                    if (!bounds.isEmpty()) {
                        map.fitBounds(bounds, {
                            padding: {
                                top: controlsHeights + 40,
                                bottom: 20,
                                left: 20,
                                right: 20
                            },
                            maxZoom: 15
                        });
                    }
                }
                console.log("Done!");
            } else {
                console.log("old Data no Zoom needed");
            }
        };

        //Function to get the category of the Gateway so the color of the line matches
        function getPointCategory(point) {
            return point.properties.deviceType === "Tester" ? "unknown" : point.properties.category || "unknown";
        };

        //Function that Returns the DeviceType from the first letters of the MacAddress
        function mapMacAddress(macAddress) {
            const macAddressStart = macAddress.slice(0, 7);
            const macAddressStartFour = macAddress.slice(0, 4);
            const macAddressStartThree = macAddress.slice(0, 3);
            if (macAddressStart === "04B6481" || macAddressStartThree === "800" || macAddressStartFour === "1C49") {
                return "IDU";
            } else if (macAddressStart === "04B6482") {
                return "ODU";
            } else if (macAddressStart === "04B6483") {
                return "GWSMART";
            } else if (macAddressStart === "04B6484") {
                return "GWHutschiene";
            } else if (macAddressStart === "7076FF0") {
                return "GWRoaming";
            }
            return null;
        };

        //Function to get the category by comparing the rssi and snr
        function rssi_snr_category(rssi, snr) {
            if (rssi >= -100) {
                if (snr > -5) {
                    return "reception possible (good)";
                } else if (snr >= -11) {
                    return "reception conditionally possible (not reliable)";
                } else {
                    return "no reception possible (bad)";
                }
            } else if (rssi >= -109) {
                if (snr > -5) {
                    return "reception conditionally possible (not reliable)";
                } else if (snr >= -11) {
                    return "reception conditionally possible (not reliable)";
                } else {
                    return "no reception possible (bad)";
                }
            } else {
                return "no reception possible (bad)";
            }
        };

        //function to process the GeoJsonData
        function processGeoJSONData(geojsonData) {
            const pointCounts = {};

            // Count points for clustering information
            geojsonData.features.forEach(feature => {
                if (feature.geometry.type === "Point") {
                    const coordKey = feature.geometry.coordinates.join(",");
                    if (!pointCounts[coordKey]) {
                        pointCounts[coordKey] = 0;
                    }
                    pointCounts[coordKey]++;
                }
            });

            // Assign point_count property to points
            geojsonData.features.forEach(feature => {
                if (feature.geometry.type === "Point") {
                    const coordKey = feature.geometry.coordinates.join(",");
                    feature.properties.point_count = pointCounts[coordKey];
                }
            });

            // Add properties to points
            geojsonData.features.forEach(feature => {
                if (feature.geometry.type === "Point") {
                    const { rssi, snr, macAddress, lora, unmapped } = feature.properties;
                    const timestamp = feature.ts?.device;

                    // Determine category (color) based on RSSI and SNR
                    feature.properties.category = rssi ? rssi_snr_category(rssi, snr) : '';

                    // Assign device type and additional attributes
                    if (macAddress) {
                        feature.properties.deviceType = mapMacAddress(macAddress);
                    } else {
                        feature.properties.deviceType = "Tester";
                        feature.properties.frame_counter = (lora?.frame_counter !== undefined && lora.frame_counter !== null)
                            ? lora.frame_counter
                            : 'unavailable';
                        feature.properties.gps_quality = unmapped?.gps_quality || 'unavailable';
                        feature.properties.timestamp = timestamp || 'unavailable';
                    }
                }
            });

            // Process lines and assign categories based on connected points
            const lineFeatures = [];
            const pointFeatures = geojsonData.features.filter(feature => feature.geometry.type === "Point");

            geojsonData.features.forEach(feature => {
                if (feature.geometry.type === "MultiLineString") {
                    feature.geometry.coordinates.forEach(line => {
                        const start = line[0];
                        const end = line[1];

                        // Find start and end points
                        const startPoint = pointFeatures.find(point =>
                            point.geometry.coordinates[0] === start[0] &&
                            point.geometry.coordinates[1] === start[1]
                        );

                        const endPoint = pointFeatures.find(point =>
                            point.geometry.coordinates[0] === end[0] &&
                            point.geometry.coordinates[1] === end[1]
                        );

                        if (startPoint && endPoint) {
                            // Determine worst category between the two connected points
                            const category = startPoint.properties.deviceType === "Tester"
                                ? getPointCategory(endPoint)
                                : getPointCategory(startPoint);

                            // Create a new feature for the line with the assigned category
                            lineFeatures.push({
                                type: "Feature",
                                geometry: {
                                    type: "LineString",
                                    coordinates: line
                                },
                                properties: {
                                    category: category
                                }
                            });
                        } else {
                            // Fallback for unknown points
                            lineFeatures.push({
                                type: "Feature",
                                geometry: {
                                    type: "LineString",
                                    coordinates: line
                                },
                                properties: {
                                    category: "unknown"
                                }
                            });
                        }
                    });
                }
            });

            // Add line features back to the GeoJSON
            geojsonData.features = geojsonData.features.filter(feature => feature.geometry.type !== "MultiLineString");
            geojsonData.features.push(...lineFeatures);
        };

        // Event listener for DevEUI selection
        document.getElementById('deveui-select').addEventListener('focus', async (event) => {
            await populateDevEUISDropdown();
        });

        document.getElementById('deveui-select').addEventListener('change', async (event) => {
            try {
                const selectedDevEUI = event.target.value;
                const isLiveView = document.getElementById('live-view').checked;
                const tsInput = document.getElementById('tsdevice-input');

                if (isLiveView) {
                    // If LiveView is checked: get newest Timestamp
                    const timestamp = await fetchtsdevice(selectedDevEUI);
                    tsInput.value = timestamp;

                    if (timestamp) {
                        // Get GeoJSON with newest Timestamp
                        await executeData(selectedDevEUI, timestamp);
                    } else {
                        console.error('No timestamp available for selected DevEUI.');
                    }
                } else {
                    // No LiveView: TSDevice-Dropdown will be populated
                    await populateTSDeviceDropdown(selectedDevEUI);
                }
            } catch (error) {
                console.error('Error handling DevEUI change:', error);
            }
        });

        // Event listener for TSDevice selection
        document.getElementById('tsdevice-select').addEventListener('click', async event => {
            const deveui = document.getElementById('deveui-select').value;

            if (!tsDataLoaded && deveui) {
                await populateTSDeviceDropdown(deveui);
            }
        });

        document.getElementById('tsdevice-select').addEventListener('change', async event => {
            const tsdevice = event.target.value;
            const deveui = document.getElementById('deveui-select').value;

            if (tsdevice && deveui) {
                await executeData(deveui, tsdevice);
            } else if (tsdevice && !deveui) {
                console.error("No DevEUI selected.");
            } else if (!tsdevice && deveui) {
                console.error("No Timestamp selected.");
            } else {
                console.error("No Timestamp and DevEUI selected.");
            }
        });

        document.getElementById('live-view').addEventListener('change', async (event) => {
            const isLiveView = event.target.checked;
            const tsSelect = document.getElementById('tsdevice-select');
            const tsInput = document.getElementById('tsdevice-input');
            const objectNumber = document.getElementById('object-number');
            const deveui = document.getElementById('deveui-select').value;
            const numberOfObjects = document.getElementById('object-number').value;
            const enableZoom = document.getElementById('enable-zoom');
            const timestamp = await fetchtsdevice(deveui);

            if (isLiveView) {
                // LiveView-Modus activated
                tsSelect.style.display = 'none';
                tsInput.style.display = 'block';
                enableZoom.disabled = false;
                objectNumber.value = 1; // Objects default value is 1 now  
                tsInput.value = timestamp;
                await executeData(deveui, timestamp);
            } else {
                // Timestamp-Modus activated
                tsSelect.style.display = 'block';
                tsInput.style.display = 'none';
                enableZoom.disabled = true;
                objectNumber.value = 20; // Object default value is 20 now
            }
        });

        //fill Dropdown as Map loads
        map.on('load', () => {
            // Populate DevEUI dropdown on load
            populateDevEUISDropdown();

            //different Types of Icons and Colors so they can be used for the Path
            const iconTypes = ["IDU", "ODU", "GWSMART", "GWHutschiene", "GWRoaming"];
            const colors = ["green", "yellow", "red", "black"];
            const colorMap = {
                "reception possible (good)": "green",
                "reception conditionally possible (not reliable)": "yellow",
                "no reception possible (bad)": "red",
            };

            //Maps Images according to the DeviceType and the Category
            iconTypes.forEach(type => {
                colors.forEach(color => {
                    const imageID = `${type}_${color}`;
                    const url = `http://localhost:8000/Icons/${imageID}.png`;//the cors_server.py script needs to be executed for this to work just save the folder icons in the same repository
                    if (!map.hasImage(imageID)) {
                        map.loadImage(url, (error, image) => {
                            if (error) {
                                console.error(`Error loading image ${url}:`, error);
                                return;
                            }
                            map.addImage(imageID, image);
                        });
                    }
                });
            });

            //Tester has the same Quality each time that's why there is only one image here
            if (!map.hasImage('Tester_black')) {
                const imageID = 'Tester_black';
                const url = `http://localhost:8000/Icons/${imageID}.png`;//the cors_server.py script needs to be executed for this to work just save the folder icons in the same repository
                map.loadImage(url, (error, image) => { //the cors_server.py script needs to be executed for this to work just save the folder icons in the same repository
                    if (error) {
                        console.error(`Error loading image Tester_black:`, error);
                        return;
                    }
                    map.addImage('Tester_black', image);
                });
            }

            setInterval(async () => {
                const isLiveView = document.getElementById('live-view').checked;
                if (isLiveView) {
                    const deveui = document.getElementById('deveui-select').value;
                    const ts = await fetchtsdevice(deveui);
                    const tsInput = document.getElementById('tsdevice-input');
                    tsInput.value = ts;
                    console.log("Refreshing Data...");
                    await executeData(deveui, ts);
                } else {
                    console.log("LiveView is off no new Data is needed...")
                }
            }, 30000)
        });

        //make some layers visible/ not visible when map gets zoomed
        map.on('zoom', () => {
            const currentZoom = map.getZoom();

            if (currentZoom < 10) {
                if (map.getLayer('clusters')) {
                    map.setLayoutProperty('clusters', 'visibility', 'visible');
                }
                if (map.getLayer('cluster-count')) {
                    map.setLayoutProperty('cluster-count', 'visibility', 'visible');
                }
                if (map.getLayer('device-icons-layer')) {
                    map.setLayoutProperty('device-icons-layer', 'visibility', 'none');
                }
                if (map.getLayer('lines-layer')) {
                    map.setLayoutProperty('lines-layer', 'visibility', 'none');
                }
            }
            else {
                if (map.getLayer('clusters')) {
                    map.setLayoutProperty('clusters', 'visibility', 'none');
                }
                if (map.getLayer('cluster-count')) {
                    map.setLayoutProperty('cluster-count', 'visibility', 'none');
                }
                if (map.getLayer('device-icons-layer')) {
                    map.setLayoutProperty('device-icons-layer', 'visibility', 'visible');
                }
                if (map.getLayer('lines-layer')) {
                    map.setLayoutProperty('lines-layer', 'visibility', 'visible');
                }
            }
        });

        //Popup texts for the icons with the mandatory informations
        map.on('click', 'device-icons-layer', (e) => {
            const features = e.features;
            const coordinates = e.features[0].geometry.coordinates.slice();

            if (features.length === 0) return;

            const popup = new mapboxgl.Popup();

            // overview for devices
            const createOverview = () => {
                return features.map((feature, index) => {
                    const properties = feature.properties;
                    const connectionColor = properties.category === 'reception possible (good)' ? '#00FF00' :
                        properties.category === 'reception conditionally possible (not reliable)' ? '#FFFF00' :
                            properties.category === 'no reception possible (bad)' ? '#FF0000' :
                                '#CCCCCC';

                    const deviceLabel = properties.deviceType === 'Tester' ? 'Tester' : properties.macAddress;

                    return `
                <div id="device-overview-${index}" 
                    style="border: 2px solid ${connectionColor}; padding: 5px; margin: 5px; cursor: pointer;" 
                    data-index="${index}">
                    ${deviceLabel}
                </div>
            `;
                }).join('');
            };

            let currentIndex = -1; // -1 shows the overview

            const showDeviceDetails = (index) => {
                const properties = features[index].properties;

                let formattedTimestamp = 'unavailable';
                if (properties.timestamp && properties.timestamp !== 'unavailable') {
                    const date = new Date(properties.timestamp * 1000);
                    formattedTimestamp = date.toLocaleString();
                }

                let description = '';
                if (properties.deviceType === 'Tester') {
                    description = `
                <strong>Device Type:</strong> Tester <br>
                <strong>Timestamp:</strong> ${formattedTimestamp} <br>
                <strong>Frame Counter:</strong> ${properties.frame_counter || 'unavailable'} <br>
                <strong>GPS Quality:</strong> ${properties.gps_quality || 'unavailable'}
            `;
                } else {
                    description = `
                <strong>Mac Address:</strong> ${properties.macAddress || 'unavailable'} <br>
                <strong>RSSI:</strong> ${properties.rssi || 'unavailable'} <br>
                <strong>SNR:</strong> ${properties.snr || 'unavailable'} <br>
                <strong>Category:</strong> ${properties.category || 'unavailable'} <br>
                <strong>Gateway Type:</strong> ${properties.deviceType || 'unavailable'} <br>
                <strong>Timestamp:</strong> ${formattedTimestamp}
            `;
                }

                const navigationControls = `
            <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                <button id="prev-device" ${index === 0 ? 'disabled' : ''}>⬅ Previous</button>
                <button id="back-to-overview" ${features.length === 1 ? 'style="display:none;"' : ''}>🔄 Overview</button>
                <button id="next-device" ${index === features.length - 1 ? 'disabled' : ''}>Next ➡</button>
            </div>
        `;

                const popupContent = `
            <div>
                <h4>Details</h4>
                ${description}
                ${navigationControls}
            </div>
        `;

                popup.setLngLat(coordinates).setHTML(popupContent).addTo(map);

                // Event-Listener for navigation
                document.getElementById('prev-device')?.addEventListener('click', () => {
                    if (currentIndex > 0) {
                        currentIndex--;
                        showDeviceDetails(currentIndex);
                    }
                });

                document.getElementById('next-device')?.addEventListener('click', () => {
                    if (currentIndex < features.length - 1) {
                        currentIndex++;
                        showDeviceDetails(currentIndex);
                    }
                });

                document.getElementById('back-to-overview')?.addEventListener('click', () => {
                    showOverview();
                });
            };

            const showOverview = () => {
                const overviewContent = `
            <div>
                <h4>Overview</h4>
                ${createOverview()}
            </div>
        `;

                popup.setLngLat(coordinates).setHTML(overviewContent).addTo(map);

                // Event-Listener to show the overview
                features.forEach((_, i) => {
                    const overviewElement = document.getElementById(`device-overview-${i}`);
                    overviewElement.addEventListener('click', () => {
                        currentIndex = parseInt(overviewElement.getAttribute('data-index'));
                        showDeviceDetails(currentIndex);
                    });
                });
            };

            // directly show details if the count is 1
            if (features.length === 1) {
                currentIndex = 0;
                showDeviceDetails(currentIndex);
            } else {
                // Initial overview
                showOverview();
            }
        });

        //Popup on Clusters
        map.on('click', 'clusters', async (e) => {
            const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
            const clusterFeature = features[0];

            // check if its a cluster or single point
            if (!clusterFeature.properties.cluster_id) {
                // if its no cluster directly show the informations
                const properties = clusterFeature.properties;
                const coordinates = clusterFeature.geometry.coordinates;

                let description = '';
                let formattedTimestamp = 'unavailable';
                if (properties.timestamp) {
                    const date = new Date(properties.timestamp * 1000);
                    formattedTimestamp = date.toLocaleString();
                }

                if (properties.deviceType === 'Tester') {
                    description = `
                <strong>Device Type:</strong> Tester <br>
                <strong>Timestamp:</strong> ${formattedTimestamp} <br>
                <strong>Frame Counter:</strong> ${properties.frame_counter || 'unavailable'} <br>
                <strong>GPS Quality:</strong> ${properties.gps_quality || 'unavailable'}
            `;
                } else {
                    description = `
                <strong>Mac Address:</strong> ${properties.macAddress || 'unavailable'} <br>
                <strong>RSSI:</strong> ${properties.rssi || 'unavailable'} <br>
                <strong>SNR:</strong> ${properties.snr || 'unavailable'} <br>
                <strong>Category:</strong> ${properties.category || 'unavailable'} <br>
                <strong>Gateway Type:</strong> ${properties.deviceType || 'unavailable'} <br>
                <strong>Timestamp:</strong> ${formattedTimestamp}
            `;
                }

                new mapboxgl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(description)
                    .addTo(map);
            } else {
                // cluster with more points
                const clusterId = clusterFeature.properties.cluster_id;

                map.getSource('dynamic-geojson').getClusterLeaves(clusterId, 100, 0, (err, leaves) => {
                    if (err) {
                        console.error('Error fetching cluster leaves:', err);
                        return;
                    }

                    let currentIndex = -1; // -1 shows the overview
                    const popup = new mapboxgl.Popup();

                    // overview with colored border
                    const createOverview = () => {
                        return leaves.map((leaf, index) => {
                            const properties = leaf.properties;
                            const connectionColor = properties.category === 'reception possible (good)' ? '#00FF00' :
                                properties.category === 'reception conditionally possible (not reliable)' ? '#FFFF00' :
                                    properties.category === 'no reception possible (bad)' ? '#FF0000' :
                                        '#CCCCCC';

                            const deviceLabel = properties.deviceType === 'Tester' ? 'Tester' : properties.macAddress;

                            return `
                        <div id="device-overview-${index}" 
                            style="border: 2px solid ${connectionColor}; padding: 5px; margin: 5px; cursor: pointer;" 
                            data-index="${index}">
                            ${deviceLabel}
                        </div>
                    `;
                        }).join('');
                    };

                    // function to show device based on index
                    const showDeviceDetails = (index) => {
                        const properties = leaves[index].properties;

                        let description = '';
                        let formattedTimestamp = 'unavailable';
                        if (properties.timestamp) {
                            const date = new Date(properties.timestamp * 1000);
                            formattedTimestamp = date.toLocaleString();
                        }

                        if (properties.deviceType === 'Tester') {
                            description = `
                        <strong>Device Type:</strong> Tester <br>
                        <strong>Timestamp:</strong> ${formattedTimestamp} <br>
                        <strong>Frame Counter:</strong> ${properties.frame_counter || 'unavailable'} <br>
                        <strong>GPS Quality:</strong> ${properties.gps_quality || 'unavailable'}
                    `;
                        } else {
                            description = `
                        <strong>Mac Address:</strong> ${properties.macAddress || 'unavailable'} <br>
                        <strong>RSSI:</strong> ${properties.rssi || 'unavailable'} <br>
                        <strong>SNR:</strong> ${properties.snr || 'unavailable'} <br>
                        <strong>Category:</strong> ${properties.category || 'unavailable'} <br>
                        <strong>Gateway Type:</strong> ${properties.deviceType || 'unavailable'} <br>
                        <strong>Timestamp:</strong> ${formattedTimestamp}
                    `;
                        }

                        const navigationControls = `
                    <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                        <button id="prev-device" ${index === 0 ? 'disabled' : ''}>⬅ Previous</button>
                        <button id="back-to-overview">🔄 Overview</button>
                        <button id="next-device" ${index === leaves.length - 1 ? 'disabled' : ''}>Next ➡</button>
                    </div>
                `;

                        const popupContent = `
                    <div>
                        <h4>Details</h4>
                        ${description}
                        ${navigationControls}
                    </div>
                `;

                        popup.setLngLat(e.lngLat).setHTML(popupContent).addTo(map);

                        // Event-Listener for navigation
                        document.getElementById('prev-device')?.addEventListener('click', () => {
                            if (currentIndex > 0) {
                                currentIndex--;
                                showDeviceDetails(currentIndex);
                            }
                        });

                        document.getElementById('next-device')?.addEventListener('click', () => {
                            if (currentIndex < leaves.length - 1) {
                                currentIndex++;
                                showDeviceDetails(currentIndex);
                            }
                        });

                        document.getElementById('back-to-overview')?.addEventListener('click', () => {
                            showOverview();
                        });
                    };

                    // function to show overview
                    const showOverview = () => {
                        const overviewContent = `
                    <div>
                        <h4>Overview</h4>
                        ${createOverview()}
                    </div>
                `;

                        popup.setLngLat(e.lngLat).setHTML(overviewContent).addTo(map);

                        // Event-Listener for clicks on overview
                        leaves.forEach((_, i) => {
                            const overviewElement = document.getElementById(`device-overview-${i}`);
                            overviewElement.addEventListener('click', () => {
                                currentIndex = parseInt(overviewElement.getAttribute('data-index'));
                                showDeviceDetails(currentIndex);
                            });
                        });
                    };

                    // Initial overview shows
                    showOverview();
                });
            }
        });

        //Change Pointer Clusters
        map.on('mouseenter', 'clusters', () => {
            map.getCanvas().style.cursor = 'pointer';
        });

        //Change Hand Clusters
        map.on('mouseleave', 'clusters', () => {
            map.getCanvas().style.cursor = '';
        });

        //Change Pointer Icons
        map.on('mouseenter', 'device-icons-layer', () => {
            map.getCanvas().style.cursor = 'pointer';
        });

        //Change Hand Icons
        map.on('mouseleave', 'device-icons-layer', () => {
            map.getCanvas().style.cursor = '';
        });
    </script>

</body>

</html>